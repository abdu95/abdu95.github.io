<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="author" content="Abduvosid Malikov">
	<title>KISS </title>

	<link rel="stylesheet" href="css/reset.css">
	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/black.css">
	<link rel="stylesheet" href="lib/css/zenburn.css">
	<link rel="stylesheet" href="css/main.css">

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="lib/css/monokai.css">

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
		document.getElementsByTagName('head')[0].appendChild(link);
	</script>
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section>KISS
				<aside class="notes">KISS is the acronym that stands for Keep It Simple</aside>
			</section>
			<section>
				<h3>Agenda</h3>
				<ol>
					<li>Definition of KISS</li>
					<li>KISS 1: less lines of code</li>
					<li>KISS 2: less complexity</li>
					<li>Summary</li>
				</ol>
				<aside class="notes">The presentation is divided into 4 parts: Definition, KISS1, KISS2, Summary</aside>
			</section>
			<section>
				<section>Definition</section>
				<section class="definition">
					<h6>KISS - "Keep It Simple Stupid"</h6>
					<p>Story of Kelly Johnson</p>
					<aside class="notes">
						The principle is best exemplified by the story of Kelly Johnson handing a team of design
						engineers a
						handful of tools, with the challenge that the jet aircraft they were designing must be
						repairable by
						an average mechanic in the field under combat conditions with only these tools.
						Hence, the "stupid" refers to the relationship between the way things break and the
						sophistication
						available to repair them.
					</aside>
				</section>
				<section class="definition-second">
					<h6>Simple things are easier to:</h6>
					<ul>
						<li><strong>understand</strong></li>
						<li><strong>maintain</strong></li>
						<li><strong>change</strong> </li>
					</ul>
					<p>So, try to keep your code and system structure simple.</p>
					<p>
						No PIE & framework magic in the code unless you can justify their need.
						Because, they always requires you to add more classes and add
						complexity to your code.
					</p>
					<aside class="notes">
						The advantage of simplicity is even bigger when the person who maintains the software is not the
						one who once wrote it.
						The maintainer might also be less familiar with sophisticated programming language features.
						So simple and stupid programs are easier to maintain because the maintainer needs less time to
						understand them and is less likely to introduce further defects.
					</aside>
				</section>
			</section>
			<section class="kiss-less-lines">
				<section>KISS 1: less lines of code</section>
				<section data-background-image="./img/KISS-medium.png" data-background-size="contain"></section>
				<section>
					<h6>1. Short-circuit Evaluation</h6>
					<pre>
						<code data-trim data-line-numbers>
							   if (var1 === null || var1 === undefined || var1 === '') {
									console.log("VARIABLE NOT FOUND!");
							   } else {
								   console.log(var1);
							   }
						</code>
					</pre>
					<pre>
						<code data-trim >
								console.log( var1 || "VARIABLE NOT FOUND!" );
						</code>
					</pre>

				</section>
				<section>
					<h6>2. Arrow Functions <strong>() =></strong> </h6>
					<pre>
						<code data-trim data-line-numbers>
							function sayHello(name) {
								console.log('Hello', name);
							}
						</code>
					</pre>
					<p>can be replaced with arrow function</p>
					<pre>
						<code data-trim data-line-numbers>
							const sayHello = name => console.log("Hello", name);
						</code>
					</pre>
					<p>different scoping methodology.</p>
				</section>
				<section>
					<h6>3. forEach </h6>
					<pre>
						<code class="hljs" data-trim data-line-numbers>
							const list = [2, 5, 7, 2, 6, 2, 3, 5];
							for (let i = 0; i < list.length; i++) {
								console.log(list[i]);
							}
						</code>
					</pre>
					<pre>
						<code class="hljs" data-trim data-line-numbers>
							list.forEach(number => console.log(number));
						</code>
					</pre>
				</section>
				<section>
					<h6>4. Default Parameters</h6>
					<pre>
						<code class="hljs" data-trim data-line-numbers>
							function volume(l, w, h) {
								if (w === undefined)
									w = 1;
								if (h === undefined)
									h = 1;
								return l * w * h;
								}
						</code>
					</pre>
					<pre>
						<code class="hljs" data-trim data-line-numbers>
							const volume = ( l, w = 1, h = 1) => l * w * h
						</code>
					</pre>
				</section>
				<section>
					<h6>5. Destructuring</h6>
					<pre><code class="hljs" data-trim data-line-numbers>
								const person = {
									first: 'Wes',
									last: 'Bos',
									country: 'Canada',
									city: 'Hamilton',
									twitter: '@wesbos'
								  };
								  const first = person.first;
								  const last = person.last;
						</code></pre>
					<p>vs</p>
					<pre><code class="hljs" data-trim>
								let { first, last } = person;
						</code></pre>
					<img src="img/Jason_Funderburker_019.webp" style="width: 300px; height:190px">
				</section>
				<section>
					<h6>6. Spread Operator</h6>
					<pre><code class="hljs" data-trim data-line-numbers>
							const odd = [1, 2, 3];
							const nums = [4, 5, 6].concat(odd);
					</code></pre>
					<p>vs</p>
					<pre><code class="hljs" data-trim data-line-numbers>
							const nums = [4, 5, 6, ...odd];
					</code></pre>
				</section>
				<section>
					<img src="img/comment.png">
					<aside class="notes">
						This comment gave me the idea that the line of code is not the only way of keeping code simple
					</aside>
				</section>
			</section>
			<section>
				<section>KISS 2: less complexity
					<aside class="notes">
						Then I asked myself "how to keep code simple?"
					</aside>
				</section>
				<section>
					simple == !complex
					<aside class="notes">
						And one logical answer was "by avoiding complexity".
						If the code is not complex then its simple.
						But there are reasons for "why we make our code complex"
					</aside>
				</section>
				<section>
					Reason 1: make code more flexible to accommodate further requirements
					<aside class="notes">
						But one cannot know in what way to make it flexible or if that flexibility will be ever needed.
						“When you make your code more flexible or sophisticated than it needs to be, you over-engineer
						it. Some do this because they believe they know their system’s future requirements. They reason
						that it’s best to make a design more flexible or sophisticated today, so it can accommodate the
						needs of tomorrow. That sounds reasonable, if you happen to be a psychic.” - Refactoring To
						Patterns - Joshua Kerievsky.
					</aside>
				</section>
				<section>
					Reason 2: optimization
					<aside class="notes">
						An optimized code is a more complex code. Pareto principle applies also in code: a program spend
						most of the time in a small portion of the code, so it will be wise to concentrate the effort to
						optimize only that part of the code. Another best practice is the to follow the “Three rules of
						optimization”: (1. Don't, 2. Don't… Yet, 3. Profile before optimizing), which make sense: to
						optimize only the code with performance problems.
					</aside>
				</section>
				<section>Example
					<pre style="font-size: 18px;"><code class="hljs" data-trim data-line-numbers>
							function weekday1(dayOfWeek){
								switch(dayOfWeek){
									case 1: return "Monday";
									case 2: return "Tuesday";
									case 3: return "Wednesday";
									case 4: return "Thursday";
									case 5: return "Friday";
									case 6: return "Saturday";
									case 7: return "Sunday";
									default: 
									  throw new Error("dayOfWeek - in range 1..7");
								}
							}									
					</code></pre>
					<pre style="font-size: 18px; width: 100%;"><code class="hljs" data-trim data-line-numbers>
							function weekday2(dayOfWeek){
								if((dayOfWeek < 1) || (dayOfWeek > 7))
									throw new Error("dayOfWeek must be in range 1..7");
								
									let weekdays = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
					
									return weekdays[dayOfWeek-1];
							}
					</code></pre>
					<aside class="notes">
						<p>Both methods do the same thing: return a string representing the weekday. Just the
							implementation is different. Both versions may be seen as simpler than the other depending
							on
							the view taken. weekday2 has less statements and less execution branches. Complexity metrics
							measuring these aspects (e.g. the cyclomatic complexity) will therefore prefer weekday2.
						</p>

						<p>On the other hand <strong>weekdays1</strong> uses less language features (just switch,
							return, and exceptions
							whereas weekdays2 needs if, arrays, arithmetic, return, and exceptions). Furthermore in
							weekdays1 the relation between input and output can be seen directly and it's clear how it
							works
							by just seeing the method. But for understanding weekday2 there are more details to think
							about.
							This is especially true for the range check at the beginning and the index computation in
							the
							return statement. Clearly this is not particularly difficult but these are aspects which are
							more difficult than in the other version of the method.
						</p>

						<p>So it's not objectively clear which of the two implementations KISS prefers without saying
							which
							complexity metric to apply. But this is OK because principles are not meant to be
							unambiguous
							and objective. Eventually a human developer decides which solution to
							implement and the principles only give guidelines.</p>
					</aside>
				</section>
			</section>
			<section>
				<section>
					<h6>Summary</h6>
					<ol>
						<li>KISS - </li>
						<li>less lines of code</li>
						<li>code with less complexity</li>
					</ol>
				</section>
				<section>
					<h6>References</h6>
					<ul>
						<li>
							<a href="https://en.wikipedia.org/wiki/KISS_principle">
								KISS principle (Wikipedia)
							</a>
						</li>
						<li>
							<a
								href="https://medium.com/infancyit/kiss-keep-it-simple-smart-javascript-habits-b019ce14b5ec">
								KISS => Keep It Simple, Smart (Medium)
							</a>
						</li>
						<li>
							<a href="http://www.principles-wiki.net/principles:keep_it_simple_stupid">
								Keep It Simple Stupid (Principles Wiki)
							</a>
						</li>
						<li>
							<a href="https://simpleprogrammer.com/kiss-one-best-practice-to-rule-them-all/">
								KISS — One Best Practice to Rule Them All (Simple Programmer)
							</a>
						</li>
						<li>
							<a href="http://people.apache.org/~fhanik/kiss.html">
								What does KISS stand for? (people.apache.org)
							</a>
						</li>
					</ul>
				</section>
				<section>
					Thank you&#128536;

				</section>
			</section>
		</div>
	</div>

	<script src="js/reveal.js"></script>

	<script>
		// More info about config & dependencies:
		// - https://github.com/hakimel/reveal.js#configuration
		// - https://github.com/hakimel/reveal.js#dependencies
		Reveal.initialize({
			dependencies: [
				{ src: 'plugin/markdown/marked.js' },
				{ src: 'plugin/markdown/markdown.js' },
				{ src: 'plugin/notes/notes.js', async: true },
				{ src: 'plugin/highlight/highlight.js', async: true }
			]
		});
	</script>
</body>

</html>